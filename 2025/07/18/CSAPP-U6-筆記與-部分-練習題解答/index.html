<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSAPP U6 筆記與(部分)練習題解答 | asciibase64</title><meta name="author" content="asciibase64"><meta name="copyright" content="asciibase64"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="深入理解計算機系統第六章筆記">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP U6 筆記與(部分)練習題解答">
<meta property="og:url" content="https://ilsao.github.io/2025/07/18/CSAPP-U6-%E7%AD%86%E8%A8%98%E8%88%87-%E9%83%A8%E5%88%86-%E7%B7%B4%E7%BF%92%E9%A1%8C%E8%A7%A3%E7%AD%94/index.html">
<meta property="og:site_name" content="asciibase64">
<meta property="og:description" content="深入理解計算機系統第六章筆記">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ilsao.github.io/pictures/CSAPP_U6.jpg">
<meta property="article:published_time" content="2025-07-18T07:20:04.000Z">
<meta property="article:modified_time" content="2025-07-18T07:25:06.358Z">
<meta property="article:author" content="asciibase64">
<meta property="article:tag" content="計算機底層原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ilsao.github.io/pictures/CSAPP_U6.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CSAPP U6 筆記與(部分)練習題解答",
  "url": "https://ilsao.github.io/2025/07/18/CSAPP-U6-%E7%AD%86%E8%A8%98%E8%88%87-%E9%83%A8%E5%88%86-%E7%B7%B4%E7%BF%92%E9%A1%8C%E8%A7%A3%E7%AD%94/",
  "image": "https://ilsao.github.io/pictures/CSAPP_U6.jpg",
  "datePublished": "2025-07-18T07:20:04.000Z",
  "dateModified": "2025-07-18T07:25:06.358Z",
  "author": [
    {
      "@type": "Person",
      "name": "asciibase64",
      "url": "https://ilsao.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/pictures/dragon.png"><link rel="canonical" href="https://ilsao.github.io/2025/07/18/CSAPP-U6-%E7%AD%86%E8%A8%98%E8%88%87-%E9%83%A8%E5%88%86-%E7%B7%B4%E7%BF%92%E9%A1%8C%E8%A7%A3%E7%AD%94/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'medium_zoom',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSAPP U6 筆記與(部分)練習題解答',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/pictures/A4.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 鏈接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情鏈接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/pictures/CSAPP_U6.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">asciibase64</span></a><a class="nav-page-title" href="/"><span class="site-name">CSAPP U6 筆記與(部分)練習題解答</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 鏈接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情鏈接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CSAPP U6 筆記與(部分)練習題解答</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-18T07:20:04.000Z" title="发表于 2025-07-18 15:20:04">2025-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-18T07:25:06.358Z" title="更新于 2025-07-18 15:25:06">2025-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSAPP/">CSAPP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="存儲技術"><a href="#存儲技術" class="headerlink" title="存儲技術"></a>存儲技術</h1><h2 id="隨機訪問存儲器"><a href="#隨機訪問存儲器" class="headerlink" title="隨機訪問存儲器"></a>隨機訪問存儲器</h2><h3 id="靜態RAM"><a href="#靜態RAM" class="headerlink" title="靜態RAM"></a>靜態RAM</h3><p>SRAM(Static Random-Access Memory)將每個位存放在<strong>雙穩態(bistable)</strong> 的存儲器單元裡。</p>
<p>SRAM可以(有電的情況下)無限期地保持在兩個不同的電壓配置(configuration，又稱狀態，state)之一。其他狀態都是不穩定的。SRAM會從不穩定狀態開始，迅速轉移到兩個穩定狀態中的一個。</p>
<p>SRAM較DRAM穩定。</p>
<h3 id="動態RAM"><a href="#動態RAM" class="headerlink" title="動態RAM"></a>動態RAM</h3><p>DRAM(Dynamic Random-Access Memory)將每個位存儲為對一個電容的充電。</p>
<p>由於DRAM較敏感，且很多原因會導致漏電，使得DRAM單元會在10~100ms內失去電荷。內存系統需要週期性的讀出數據，並重寫刷新內存中的每一位。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>每位晶體管數</th>
<th>相對訪問時間</th>
<th>持續的</th>
<th>敏感的</th>
<th>相對花費</th>
<th>應用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SRAM</td>
<td>6</td>
<td>$1\times$</td>
<td>是</td>
<td>否</td>
<td>$1000\times$</td>
<td>高速緩存存儲區</td>
</tr>
<tr>
<td>DRAM</td>
<td>6</td>
<td>$10\times$</td>
<td>否</td>
<td>是</td>
<td>$1\times$</td>
<td>主存、幀緩衝區</td>
</tr>
</tbody>
</table>
</div>
<h3 id="傳統的DRAM"><a href="#傳統的DRAM" class="headerlink" title="傳統的DRAM"></a>傳統的DRAM</h3><p>DRAM芯片中的單元(位)被分成$d$個<strong>超單元(supercell)</strong>，每個超單元由$w$個DRAM單元組成。一個$d \times w$的DRAM總共存儲了$dw$位信息，其中$w$代表每個超單元可以存儲多少位。</p>
<p>每個超單元有形如$(i,j)$的地址，$i$表示row，$j$表示column。</p>
<p>信息通過<strong>引腳(pin)</strong> 的外部連接器流入和流出芯片，每個引腳攜帶1位信號。</p>
<p>每個DRAM芯片連接到<strong>內存控制器(memory controller)</strong> 電路，此電路一次可以傳送或讀取$w$位數據。</p>
<p>讀出超單元$(i,j)$的內容時，內存控制器先將$i$傳給DRAM，然後才將$j$傳給DRAM，最後DRAM傳回$(i,j)$的內容。其中，$i$稱為RAS(Row Access Strobe)請求，$j$稱為CAS(Column Access Strobe)請求。注意，$i$和$j$共享一個DRAM地址引腳。</p>
<p><img src="/pictures/CSAPP_U6/1.png" alt="1"></p>
<p>將DRAM組織成二維陣列而不是線性數組的原因是：假設128位($16 \times 8$)DRAM被組織成一個16個超單元的線性數組，地址為0~15，芯片需要4個地址引腳而不是2個。</p>
<p>二維陣列的缺點是訪問時間較長(分兩步驟)。</p>
<h3 id="內存模塊"><a href="#內存模塊" class="headerlink" title="內存模塊"></a>內存模塊</h3><p>DRAM芯片封裝在<strong>內存模塊(memory module)</strong> 中，它插到主板的擴展槽上。</p>
<p>下圖展示一個內存模塊的基本模型。</p>
<p><img src="/pictures/CSAPP_U6/2.png" alt="2"></p>
<p>圖中展示8個DRAM，每個DRAM存儲64MB($8M \times 8$)，且這8個芯片編號0~7。</p>
<p>要存儲8字節(64位)的數據，每個DRAM中的一個超單元會存儲主存的一個字節。其中，DRAM 0存儲第一個(低位)字節，依此類推。</p>
<p>要取出內存地址A的一個字，內存控制器將A轉換成一個超單元地址$(i,j)$並發送到內存模塊，然後內存模塊將$i$和$j$廣播到每個DRAM。最後，將每個DRAM的響應合成為一個64位字，再返回給內存控制器。</p>
<p>將多個內存模塊連接到內存控制器，可以合成主存。此時，當控制器收到地址A時，控制器選擇包含A的模塊$k$，將A轉換成$(i,j)$形式，並發送到模塊$k$。</p>
<h3 id="練習題"><a href="#練習題" class="headerlink" title="練習題"></a>練習題</h3><p>6.1</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>組織</th>
<th>$r$</th>
<th>$c$</th>
<th>$b_{r}$</th>
<th>$b_{c}$</th>
<th>$max(b<em>{r}, b</em>{c})$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$16\times 1$</td>
<td>4</td>
<td>4</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>$16  \times 4$</td>
<td>4</td>
<td>4</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>$128 \times 8$</td>
<td>16</td>
<td>8</td>
<td>4</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>$512 \times 4$</td>
<td>32</td>
<td>16</td>
<td>5</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>$1024 \times 4$</td>
<td>32</td>
<td>32</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="非易失性存儲器"><a href="#非易失性存儲器" class="headerlink" title="非易失性存儲器"></a>非易失性存儲器</h3><p>若斷電，DRAM和SRAM會丟失信息。此時，它們是<strong>易失的(volatile)</strong>。另一方面，<strong>非易失性存除器(nonvolatile memory)</strong> 在斷電後仍保存信息。</p>
<p><strong>只讀存儲器(Read-Only Memory, ROM)</strong> 由於歷史原因，有些類型可讀也可寫。ROM以能被重編程(寫)的次數和重編程的機制來區分。</p>
<p><strong>PROM(Programmable ROM，可編程ROM)</strong>只能被編程一次，PROM的存儲器單元有一種<strong>熔絲(fuse)</strong>，只能被高壓電熔斷一次。</p>
<p><strong>可擦寫可編程 ROM(Erasable Programmable ROM, EPROM)</strong> 允許使用紫外線將單元清除成0。對EPROM編程需要使用特殊設備。</p>
<p><strong>電子可擦除 PROM(Electrically Erasable PROM, EEPROM)</strong> 類似EPROM，但不需要獨立的編程設備。</p>
<p><strong>閃存(flash memory)</strong> 基於ERPROM。</p>
<p>存儲在ROM中的程序被稱為固件(firmware)。當計算機系統通電後，就會運行固件。</p>
<h3 id="訪問主存"><a href="#訪問主存" class="headerlink" title="訪問主存"></a>訪問主存</h3><p>數據流通過<strong>總線(bus)</strong> 在CPU和主存傳遞。每次數據傳輸通過一系列步驟完成，稱這些步驟<strong>總線事務(bus transaction)</strong>。<strong>讀事務(read transaction)</strong> 從主存傳遞數據到CPU，<strong>寫事務(write transaction)</strong> 從CPU傳遞數據到主存。</p>
<p>總線是一組並行的導線，可以攜帶地址、數據和控制信號。控制線攜帶的信號會同步事務，並標示出當前正在執行的總線類型。</p>
<p><img src="/pictures/CSAPP_U6/3.png" alt="3"></p>
<p>上圖展示一個計算機系統的配置。</p>
<p>主要部件是CPU、I/O橋接器(I/O bridge，包括內存控制器)和主存。</p>
<p>這些部件由一對總線連接，系統總線(system bus)和內存總線(memory bus)。I/O橋接器會將系統總線的信號轉換成內存總線的信號。</p>
<p>考慮以下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq A, %rax</span><br></pre></td></tr></table></figure>
<p>地址A要被加載到<code>%rax</code>中。CPU中稱為<strong>總線接口(bus interface)</strong> 的電路在總線上發起讀事務。</p>
<p>讀事務由三步驟組成：</p>
<ol>
<li>CPU將地址A放到系統總線上，I/O橋將信號傳遞到內存總線。</li>
<li>主存收到內存總線的信號，從內存總線讀取地址，再從DRAM取出數據，並將數據寫到內存總線。I/O橋傳遞到系統總線。</li>
<li>CPU收到信號，更新<code>%rax</code>。</li>
</ol>
<p>反過來，考慮以下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq %rax, A</span><br></pre></td></tr></table></figure>
<p>寫事務由三個步驟組成：</p>
<ol>
<li>CPU將地址傳遞，內存從內存總線讀出地址，並等待數據到達。</li>
<li>CPU將<code>%rax</code>中的數據傳遞。</li>
<li>主存從內存總線讀數據，並將數據存儲到DRAM中。</li>
</ol>
<h2 id="磁盤存儲"><a href="#磁盤存儲" class="headerlink" title="磁盤存儲"></a>磁盤存儲</h2><p>磁盤由<strong>盤片(platter)</strong> 構成，每個盤面有兩面，稱為<strong>表面(surface)</strong>。盤片中央有一個可以旋轉的<strong>主軸(spindle)</strong>，使得盤片以固定<strong>旋轉速率(rotational rate)</strong> 旋轉，通常是5400~15000<strong>轉每分鐘(Revolution Per Minute, RPM)</strong>。</p>
<p>每個表面由多組稱<strong>磁道(track)</strong> 的同心圓組成。每個磁道被劃分成多組<strong>扇區(sector)</strong>，每個扇區通常包含512字節的數據。扇區間由間隙隔開，間隙存儲用來標示扇區的格式化位。</p>
<p>硬盤的容量由以下因素決定：</p>
<ul>
<li><strong>紀錄密度(recodring density)</strong>：磁道一英吋的段中可以放入的位數。</li>
<li><strong>磁道密度(track density)</strong>：從盤片中心出發半徑上一英吋內可以有的磁道數。</li>
<li><strong>面密度(areal density)</strong>：紀錄密度和磁道密度的乘積。</li>
</ul>
<p>磁盤用<strong>讀/寫頭(read/write head)</strong> 來讀寫存儲在磁性表面的位，讀寫頭連接到<strong>傳動臂(actuator arm)</strong> 的一端。每個盤面都有一個獨立的讀寫頭。</p>
<p>通過延半徑前後移動，傳動臂可以將讀寫頭定位道任何磁道上，此行為稱<strong>尋道(seek)</strong>。</p>
<p>對扇區的<strong>訪問時間(access time)</strong> 由三個因素決定：<strong>尋道時間(seek time)</strong>、<strong>旋轉時間(rotational latency)</strong>、<strong>傳送時間(transfer time)</strong>。</p>
<ul>
<li>尋道時間($T_{se ek }$)：移動傳動臂所需的時間。</li>
<li>旋轉時間($T_{\text{rotation}}$)：驅動器等待目標扇區的第一位旋轉到讀寫頭下的時間。</li>
<li>傳送時間($T_{\text{transfer}}$)：轉過一個扇區所需的時間。</li>
</ul>
<p>為了對操作系統隱藏不必要的複雜，現代磁盤將結構呈現為更簡單的視圖：一個$B$個扇區大小的<strong>邏輯塊</strong>序列，編號為$0,1,\cdots ,B-1$。</p>
<p>磁盤封裝中有一個設備，稱作磁盤控制器，維護著邏輯塊號與物理磁盤扇區間的映射關係。</p>
<p>當系統要執行一個I/O操作時，會發送命令到磁盤控制器，讓其讀取某個邏輯塊號。控制器上的固件會執行快速表查找，將邏輯塊號轉換成$(盤面，磁道，扇區)$的三元組。控制器的硬件會解釋該三元組，控制讀寫頭移動到該區並執行操作。</p>
<p>如顯卡、鼠標、鍵盤等I/O設備，都是通過<strong>I/O總線</strong>連接到CPU和主存的。與系統總線和內存總線不同，I/O總線設計與底層CPU無關。</p>
<p><img src="/pictures/CSAPP_U6/4.png" alt="4"></p>
<p>上圖為一個I/O總線結構，它連接了CPU、主存和I/O設備。</p>
<p>I/O總線較系統、內存總線慢，但可容納第三方I/O設備：</p>
<ul>
<li><strong>通用串行總線(Universal Serial Bus, USB)</strong></li>
<li><strong>圖形卡</strong>或<strong>適配器</strong></li>
<li><strong>主機總線適配器(Host Bus Adapter)</strong>：將磁盤連接到I/O總線，使用的是主機總線接口定義的通信協議。SCSI(讀scuzzy)和SATA(讀sat-uh)是兩個最常用的磁盤接口，SCSI比SATA快且支持多個磁盤驅動器。</li>
</ul>
<p>CPU使用<strong>內存映射I/O(memory-mapped I/O)</strong> 向設備發送指令。在系統中，地址空間中有一塊地址為I/O通信保留，每個這樣的地址稱<strong>I/O端口(I/O port)</strong>。當一個設備連接到總線時，它被映射到一個或多個端口。</p>
<p>假設磁盤控制器映射到端口<code>0xa0</code>。則CPU通過三個對地址<code>0xa0</code>的存儲指令發起磁盤讀：</p>
<ol>
<li>發送命令字，告訴磁盤發起了磁盤讀，並包含其他參數，比如讀完成後是否中斷CPU。</li>
<li>指明讀的邏輯塊號。</li>
<li>指明哪個主存地址應儲存磁盤扇區中的內容。</li>
</ol>
<p>當磁盤控制器接收到CPU的指令，它會將邏輯塊號翻譯成扇區地址，並讀取該扇區中的內容，然後直接將該內容傳入主存，不需要CPU的干涉。</p>
<p>設備可執行寫或讀總線事務而不經過CPU干涉的過程，稱<strong>直接內存訪問(Direct Memory Access, DMA)</strong>。而這種數據傳送稱<strong>DMA傳送(DMA transfer)</strong>。</p>
<p>DMA傳送完成後，磁盤控制器給CPU發送中斷信號。當CPU芯片引腳收到信號，會導致CPU暫停當前操作，跳轉到操作系統例程，該程序會記錄I/O完成，然後將控制返回到CPU被中斷的地方。</p>
<p>以上行為如下圖所示：</p>
<p><img src="/pictures/CSAPP_U6/5.png" alt="5"></p>
<h3 id="練習題-1"><a href="#練習題-1" class="headerlink" title="練習題"></a>練習題</h3><p>6.3</p>
<p>$T_{\text{avg rotation}} = \frac{1}{2}\times \frac{1}{15000}min \times 60s \times 1000ms \approx 2ms$</p>
<p>$T_{\text{avg transfer}} = \frac{1}{15000}\text{min}\times \frac{1}{500} \times 60s \times 1000ms \approx 0.008ms$</p>
<p>$T_{access} = 8+2+0.008 \approx 10ms$</p>
<h2 id="固態硬盤"><a href="#固態硬盤" class="headerlink" title="固態硬盤"></a>固態硬盤</h2><p><strong>固態硬盤(Solid State Disk, SSD)</strong> 基於閃存。一個SSD封裝由一個或多個閃存和<strong>閃存翻譯層(flash translation layer)</strong> 組成，閃存翻譯層是一個硬件/固件設備，充當磁盤控制器的角色，將對邏輯塊的請求翻譯成對底層物理設備的訪問。</p>
<p><img src="/pictures/CSAPP_U6/6.png" alt="6"></p>
<p>一個閃存由$B$個塊組成，每個塊由$P$個頁組成。通常，頁的大小為512字節到4KB，塊由32到128頁組成，塊的大小為16KB到512KB。</p>
<p>數據以頁為單位進行讀寫，但只有在頁所屬的塊<strong>被擦除</strong>後，才能寫這一頁(通常指該塊所有位被設為1)。</p>
<p>隨機寫很慢，有兩個原因：</p>
<ol>
<li>擦除塊需要很長的時間，1ms級，比訪問頁慢了一個數量級。</li>
<li>若操作試圖修改包含已經有數據的頁$p$(即非全1)，則該塊中所有帶有有效數據的頁都必須複製到一個(擦除過的)新塊，然後才能進行對頁$p$的寫。</li>
</ol>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p><strong>局部性(locality)</strong> 通常有兩種不同形式：</p>
<ol>
<li><strong>時間局部性(temporal locality)</strong>：被引用過的內存位置很可能在不久被多次引用。</li>
<li><strong>空間局部性(spatial locality)</strong>：一個內存位置被引用過後，附近的內存位置很可能在不久被引用。</li>
</ol>
<p><strong>高速緩存存儲器</strong>保存最近被引用的指令和數據，從而提高對主存的訪問速度。</p>
<p>在操作系統級，局部性原理使得系統使用主存作為虛擬地址最近被引用塊的高速緩存。類似地，操作系統用主存來緩存磁盤文件中最近被使用的磁盤塊。</p>
<p>考慮以下代碼：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumvec</span><span class="params">(<span class="type">int</span> v[N])</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i; i &lt; N; i++) &#123;</span><br><span class="line">		sum += v[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>sum</code>具有良好的時間局部性，且因為<code>sum</code>是標量，所以沒有空間局部性。而對<code>v</code>來說，它具有良好的空間局部性，但是時間局部性卻很差，因為函數中從不會多次調用<code>v</code>的同一項。</p>
<p>像<code>sumvec</code>這樣順序訪問一個向量每個元素的函數，稱<strong>步長為1的引用模式(stride-1 reference pattern，或稱順序引用模式 sequential reference pattern)</strong>(相對於元素的大小)。在一個向量中，每隔$k$個元素進行訪問，就稱<strong>步長為$k$的引用模式(stride-k reference pattern)</strong>。一般來說，$k$越大，空間局部性越小。</p>
<p>對於取指令來說，循環有好的時間、空間局部性。循環體越小，循環迭代次數越多，局部性越好。</p>
<h2 id="練習題-2"><a href="#練習題-2" class="headerlink" title="練習題"></a>練習題</h2><p>6.7</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarray3d</span><span class="params">(<span class="type">int</span> a[N][N][N])</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">				sum += a[i][j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.8</p>
<p><code>clear1</code> &gt; <code>clear2</code> &gt; <code>clear3</code></p>
<p>分兩部分看：首先<code>clear1</code>和<code>clear2</code>有同樣的raw-major ordered讀數組，比<code>clear3</code>的column-major oredered空間局部性好。其次，因為結構體內的變量在內存中線性排列，所以<code>clear1</code>統一設置完一個結構再設置下一個結構的行為比<code>clear2</code>的空間局部性好。</p>
<h1 id="存儲器層次結構"><a href="#存儲器層次結構" class="headerlink" title="存儲器層次結構"></a>存儲器層次結構</h1><p>下圖是一個典型的<strong>存儲器層次結構(memory hierarchy)</strong>。</p>
<p><img src="/pictures/CSAPP_U6/7.png" alt="7"></p>
<h2 id="存儲器層次結構中的緩存"><a href="#存儲器層次結構中的緩存" class="headerlink" title="存儲器層次結構中的緩存"></a>存儲器層次結構中的緩存</h2><p>存儲器層次結構的中心思想是，對於每層$k$，會做為$k+1$層的緩存。</p>
<p>第$k+1$層的存儲器被劃分成連續的數據對象組塊(chunk)，稱為<strong>塊(block)</strong>。而第$k$層則被劃分成更少塊的集合，且每個塊的大小與第$k+1$一樣。第$k$層的緩存是$k+1$層塊的子集副本。</p>
<p>數據以塊大小為<strong>傳送單元(transfer unit)</strong> 在兩層之間來回複製。</p>
<p>雖然相鄰的層次之間塊大小是固定的，但是其他的層次對之間可以有不同大小的塊。</p>
<p>當程序需要$k+1$層的數據$d$時，程序首先在第$k$層尋找$d$，如果$d$緩存在$k$，則<strong>緩存命中(cache hit)</strong>，否則<strong>緩存不命中(cache miss)</strong>。</p>
<p>緩存不命中時，需要覆蓋一個現存的塊，稱<strong>替換(replacing)</strong> 或 <strong>驅逐(evicting)</strong> 這個塊。被驅逐的塊稱<strong>犧牲塊(victim block)</strong>。</p>
<p><strong>強制性不命中(compulsory miss，或稱冷不命中, cold miss)</strong>：第$k$層為空(<strong>冷緩存, cold cache</strong>)時發生。不會在反覆訪問存儲器使得緩存<strong>暖身(warmed up)</strong> 後發生。</p>
<p>當不命中時，需要執行<strong>放置策略(placement policy)</strong> 以確定將$k+1$層的塊放置在哪。例如第$k+1$層的塊必須放在第$k$層的塊$(i \text{ mod } 4)$中。此時，容易引發<strong>衝突不命中(conflict miss)</strong>，如果程序反覆請求塊0和塊8，則每次引用都不會命中，即使這個緩存可以容納大於兩個塊。</p>
<h1 id="高速緩存存儲器"><a href="#高速緩存存儲器" class="headerlink" title="高速緩存存儲器"></a>高速緩存存儲器</h1><p><img src="/pictures/CSAPP_U6/8.png" alt="8"></p>
<p>由於CPU和主存的差距漸大，設計者在CPU寄存器文件與主存之間插入一個SRAM<strong>高速緩存存儲器</strong>，稱為<strong>L1高速緩存</strong>或<strong>一級緩存</strong>，典型的訪問時間是4個時鐘週期。</p>
<h2 id="通用的高速緩存存儲器組織結構"><a href="#通用的高速緩存存儲器組織結構" class="headerlink" title="通用的高速緩存存儲器組織結構"></a>通用的高速緩存存儲器組織結構</h2><p>考慮一個系統，其存儲器地址有$m$位，形成$M=2^{m}$個不同的地址。</p>
<p><img src="/pictures/CSAPP_U6/9.png" alt="9"></p>
<p>如圖所示，高速緩存被組織成有$S=2^{s}$個高速緩存組的數組。每個組包含$E$個<strong>高速緩存行(cache line)</strong>。每個行由一個<strong>有效位(valid bit)</strong>，一個$B=2^{b}$字節的數據塊(block)，還有$t=m-(b+s)$個<strong>標記位(tag bit)</strong> 組成。</p>
<p>高速緩存結構可以用$(S, E, B, m)$描述。而高速緩存的大小指所有數據塊地和，即$C=S\times E\times B$。</p>
<p>如何檢查緩存中是否包含某個元素：</p>
<ol>
<li>將$m$劃分成三個字段，其中$s$個<strong>組引索位</strong>指明是$S$中的哪一項。</li>
<li>$t$個<strong>標記位</strong>指明該組的哪一行包含這個數據，同時確認數據是否有效。</li>
<li>最後，由$b$個<strong>塊偏移位</strong>指明在$B$個字節的數據塊中的偏移。</li>
</ol>
<h3 id="練習題-3"><a href="#練習題-3" class="headerlink" title="練習題"></a>練習題</h3><p>6.9</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>高速緩存</th>
<th>$m$</th>
<th>$C$</th>
<th>$B$</th>
<th>$E$</th>
<th>$S$</th>
<th>$t$</th>
<th>$s$</th>
<th>$b$</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td>256</td>
<td>22</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>2.</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td>32</td>
<td>24</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>3.</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td>1</td>
<td>27</td>
<td>0</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h2 id="直接映射高速緩存"><a href="#直接映射高速緩存" class="headerlink" title="直接映射高速緩存"></a>直接映射高速緩存</h2><p>依據每個組的高速緩存行數$E$，高速緩存被分成不同類。在$E=1$的情況下，我們稱<strong>直接映射高速緩存(direct-mapped cache)</strong>。以下，我們使用直接映射高速緩存介紹通用概念。</p>
<p><img src="/pictures/CSAPP_U6/10.png" alt="10"></p>
<p>高速緩存確定一個請求是否命中，然後抽出被請求字的過程，分三步：</p>
<ol>
<li>組選擇</li>
<li>行匹配</li>
<li>字抽取</li>
</ol>
<p>1.組選擇</p>
<p>高速緩存從$w$的地址中間取出$s$個組索引位，並將其解釋成對應組號(無符號數)。</p>
<p><img src="/pictures/CSAPP_U6/11.png" alt="11"></p>
<p>2.行匹配</p>
<p>當確認該行設置了有效位後，確認高速緩存行中的標記是否與$w$的地址中的標記相匹配。</p>
<p>3.字抽取</p>
<p>確認命中後，我們需要從塊中取得我們需要的字。通過塊偏移位我們可以將高速緩存看做數組，通過偏移來訪問。</p>
<p><img src="/pictures/CSAPP_U6/12.png" alt="12"></p>
<p>4.緩存不命中時的行替換</p>
<p>若緩存不命中，需要從存儲器結構中的下一層取出被請求的塊。</p>
<p>對於直接映射高速緩存來說，替換策略是：用新的行替換當前行。</p>
<p>5.直接映射衝突不命中</p>
<p>回想衝突不命中的概念，即：有足夠的高速緩存空間，但是塊卻交替地映射到同一個組。</p>
<p>當程序訪問大小為2的冪的數組時，直接映射高速緩存通常會發生衝突不命中。</p>
<p>考慮以下函數：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">dotprod</span><span class="params">(<span class="type">float</span> x[<span class="number">8</span>], <span class="type">float</span> y[<span class="number">8</span>])</span> &#123;</span><br><span class="line">	<span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		sum += x[i] * y[i];</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按理來說，<code>x</code>和<code>y</code>具有良好的空間局部性，所以命中率較高。可事實完全相反，命中率很低。</p>
<p>假設一個塊16字節，且高速緩存中有兩個組，每個組只能容納一行。我們可以得到下表：</p>
<p><img src="/pictures/CSAPP_U6/13.png" alt="13"></p>
<p>由上表可見，每次對<code>x</code>和<code>y</code>的引用都會導致衝突不命中，因為我們在<code>x</code>和<code>y</code>的塊之間<strong>抖動(thrash)</strong>。抖動指的是高速緩存反覆地加載和驅逐相同組中的塊。</p>
<p>想修正抖動，我們可以在數組結尾處填充$B$個字節。例如將<code>x[8]</code>改為<code>x[12]</code>，即填充16字節(4個浮點數)。</p>
<p><img src="/pictures/CSAPP_U6/14.png" alt="14"></p>
<h3 id="練習題-4"><a href="#練習題-4" class="headerlink" title="練習題"></a>練習題</h3><p>6.10</p>
<p>命中率：3/4</p>
<p>6.11</p>
<p>A. 有$2^{t}$個塊</p>
<p>B. </p>
<p>$s=9, t=18, b=5$</p>
<p>$\frac{4096\times4}{32} &lt; 2^{18}$所以<code>array</code>中的所有數據都被映射在同一組中，即最大數量為1。</p>
<h2 id="組相聯高速緩存"><a href="#組相聯高速緩存" class="headerlink" title="組相聯高速緩存"></a>組相聯高速緩存</h2><p>直接映射高速緩存發生衝突不命中的原因在於每個組只有一行的限制，而<strong>組相聯高速緩存(set associative cache)</strong> 則放鬆了這條限制。</p>
<p>對一個$1 &lt; E &lt; \frac{C}{B}$的高速緩存稱$E$路組相聯高速緩存。</p>
<p>下圖展示了一個2路組相聯高速緩存的結構。</p>
<p><img src="/pictures/CSAPP_U6/15.png" alt="15"></p>
<p>1.組選擇：與直接映射高速緩存的組選擇方法相同。</p>
<p>2.行匹配與字選擇</p>
<p>傳統內存像數組，而<strong>相聯存儲器</strong>更像一個哈希表，利用<code>(key, value)</code>存放數據。</p>
<p>由於組相聯高速緩存一個組內有多行，所以必須搜索組中每行，確認有效，並匹配標記。</p>
<p>3.緩存不命中時的行替換</p>
<p>緩存不命中時，若組內有空行則直接加載入該行。</p>
<p>若沒有空行，可以使用以下幾個策略：</p>
<ul>
<li>隨機選擇</li>
<li><strong>最不常使用(Least-Frequently-Used, LFU)</strong>：引用次數最少</li>
<li><strong>最近最少使用(Least-Recently-Used, LRU)</strong>：最後一次訪問最久遠</li>
</ul>
<h2 id="全相聯高速緩存"><a href="#全相聯高速緩存" class="headerlink" title="全相聯高速緩存"></a>全相聯高速緩存</h2><p><strong>全相聯高速緩存(fully associative cache)</strong> 一個組包含所有高速換存行($E=\frac{C}{B}$)。</p>
<p>1.組選擇</p>
<p>注意，全相聯高速緩存下，地址沒有組索引位。</p>
<p><img src="/pictures/CSAPP_U6/16.png" alt="16"></p>
<h2 id="練習題-5"><a href="#練習題-5" class="headerlink" title="練習題"></a>練習題</h2><p>6.12</p>
<p>CO: 1~0</p>
<p>CI: 4~2</p>
<p>CT: 12~5</p>
<p>6.13</p>
<p>A. <code>0111000110100</code></p>
<p>B. </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>參數</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>CO</td>
<td><code>0x0</code></td>
</tr>
<tr>
<td>CI</td>
<td><code>0x5</code></td>
</tr>
<tr>
<td>CT</td>
<td><code>0x71</code></td>
</tr>
<tr>
<td>緩存命中?</td>
<td>是</td>
</tr>
<tr>
<td>返回的字節</td>
<td><code>0xB</code></td>
</tr>
</tbody>
</table>
</div>
<p>6.14</p>
<p>A. <code>0110111010101</code></p>
<p>B. </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>參數</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>CO</td>
<td><code>0x1</code></td>
</tr>
<tr>
<td>CI</td>
<td><code>0x5</code></td>
</tr>
<tr>
<td>CT</td>
<td><code>0x6E</code></td>
</tr>
<tr>
<td>緩存命中?</td>
<td>否</td>
</tr>
<tr>
<td>返回的字節</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>6.15</p>
<p>A. <code>1111111100100</code></p>
<p>B.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>參數</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>CO</td>
<td><code>0x0</code></td>
</tr>
<tr>
<td>CI</td>
<td><code>0x1</code></td>
</tr>
<tr>
<td>CT</td>
<td><code>0xFF</code></td>
</tr>
<tr>
<td>緩存命中?</td>
<td>否</td>
</tr>
<tr>
<td>返回的字節</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p>6.16</p>
<p><code>0011001001100</code> <code>0011001001101</code>  <code>0011001001110</code> <code>0011001001111</code></p>
<p><code>0x64C</code> <code>0x64D</code> <code>0x64E</code> <code>0x64F</code></p>
<h2 id="有關寫的問題"><a href="#有關寫的問題" class="headerlink" title="有關寫的問題"></a>有關寫的問題</h2><p>讀取上文已經介紹過了，現在來考慮寫的問題，假設我們要寫一個已經緩存的字$w$(<strong>寫命中，write hit</strong>)。</p>
<p>寫命中時，兩種方法：</p>
<ul>
<li><strong>直寫(write-through)</strong>：立即將$w$的高速緩存塊寫入到低一層中。</li>
<li><strong>寫回(write-back)</strong>：推遲更新，僅當替換算法要驅逐該塊時，才寫入到低一層中。缺點是必須額外維護一個<strong>修改位(dirty bit)</strong>，表明該塊是否被修改過。</li>
</ul>
<p>寫不命中時，兩種方法：</p>
<ul>
<li><strong>寫分配(write-allocate)</strong>：加載低一層的塊到高速緩存中，然後更新。寫回高速緩存通常使用。</li>
<li><strong>非寫分配(not-write-allocate)</strong>：避開高速緩存，直接將字寫到低一層中。直寫高速緩存通常使用。</li>
</ul>
<h1 id="編寫高速緩存友好的代碼"><a href="#編寫高速緩存友好的代碼" class="headerlink" title="編寫高速緩存友好的代碼"></a>編寫高速緩存友好的代碼</h1><p>以下是編寫<strong>高速緩存友好(cache friendly)</strong> 代碼的基本方法：</p>
<ol>
<li>讓最常見的情況跑得快</li>
<li>減少循環內部的緩存不命中數</li>
</ol>
<p>一個步長為$k$的引用模式($k$以字為單位)平均每次迭代會有$\text{min}\left( 1,\text{wordsize}\times k\times \frac{1}{B} \right)$次緩存不命中。</p>
<p>對於局部變量，合理優化的編譯器會將它們緩存在寄存器文件中，即最高層。</p>
<p>對多維數組來說，空間局部性非常重要。</p>
<h2 id="練習題-6"><a href="#練習題-6" class="headerlink" title="練習題"></a>練習題</h2><p>6.17</p>
<p>$S=2,B=8,s=1,b=3$</p>
<p>A.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>dst</code></th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>m</td>
<td>m</td>
</tr>
<tr>
<td>1</td>
<td>m</td>
<td>m</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>src</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>m</td>
<td><del>h</del> <strong>m</strong></td>
</tr>
<tr>
<td>1</td>
<td>m</td>
<td>h</td>
</tr>
</tbody>
</table>
</div>
<p><code>src[0][1]</code>是<code>m</code>，因為高速緩存空間有限， 對<code>dst[0][0]</code>的寫會驅逐<code>src[0][0]</code>加載時的那一行。</p>
<p>B.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>dst</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>m</td>
<td>h</td>
</tr>
<tr>
<td>1</td>
<td>m</td>
<td>h</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>src</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>m</td>
<td>h</td>
</tr>
<tr>
<td>1</td>
<td>m</td>
<td>h</td>
</tr>
</tbody>
</table>
</div>
<p>6.18</p>
<p>$S=64, B=16(\text{4個int，兩個algae_position}), s=6, b=4$</p>
<p>A. 512</p>
<p>B. </p>
<p>$8\times 16=128$</p>
<p>因為<code>x</code>與<code>y</code>分開使用兩個循環讀取，而一次循環有256次讀操作，大於高速緩存組的總數，所以讀<code>y</code>時並不會由於上方循環的緩存而命中。</p>
<p>$128 \times 2 =256$</p>
<p>C. 1/2</p>
<p>6.19</p>
<p>A. 512</p>
<p>B. </p>
<p>$16\times 8=128 \ \times$</p>
<p>因為組數量為64，只能存儲一半的數組，所以當訪問到<code>grid[8][0]</code>時，會將<code>grid[0][0]</code>的塊驅逐(如果通過地址計算，二者映射到的組相同)。導致下次訪問<code>grid[0][1]</code>時不命中(衝突不命中)。所以正確答案是：</p>
<p>$16 \times 16 = 256$</p>
<p>C. 1/2</p>
<p>D. 1/4</p>
<p>6.20</p>
<p>A. 512</p>
<p>B. $8 \times 16=128$</p>
<p>C. 1/4</p>
<p>D. 1/4</p>
<h1 id="綜合：高速緩存對程序性能的影響"><a href="#綜合：高速緩存對程序性能的影響" class="headerlink" title="綜合：高速緩存對程序性能的影響"></a>綜合：高速緩存對程序性能的影響</h1><h2 id="重新排列循環以提高空間局部性"><a href="#重新排列循環以提高空間局部性" class="headerlink" title="重新排列循環以提高空間局部性"></a>重新排列循環以提高空間局部性</h2><script type="math/tex; mode=display">
\begin{bmatrix}
c_{11} & c_{12} \\
c_{21} & c_{22}
\end{bmatrix}
=
\begin{bmatrix}
a_{11} & a_{12} \\
a_{21} & a_{22}
\end{bmatrix}
\begin{bmatrix}
b_{11} & b_{12} \\
b_{21} & b_{22}
\end{bmatrix}</script><p>考慮上式矩陣相乘操作，通常使用三個嵌套的循環實現。排列三個變量<code>i, j, k</code>可以取得三種不同的版本。</p>
<p>為了分析各版本，做以下假設：</p>
<ul>
<li>每個數組都是<code>double</code>類型，<code>sizeof(double) == 8</code>。</li>
<li>只有一個高速緩存，其塊大小為32字節。</li>
<li>數組大小<code>n</code>很大，矩陣的任一行都沒法完全裝進L1高速緩存中。</li>
</ul>
<p><img src="/pictures/CSAPP_U6/17.png" alt="17"></p>
<p>(a)與(b)每次迭代執行兩個加載。內循環以步長1掃描數組A的一行，A的不命中率為每次迭代不命中0.25次。以步長1掃描數組B的一列，因為<code>n</code>夠大，所以每次對B的訪問都不會命中，B的每次迭代都不命中。所以每次迭代總和會有1.25次不命中。</p>
<p>(c)與(d)每次迭代執行兩個加載和一個存儲。內循環掃描A與C的列，每次都不命中，所以每次迭代有2次不命中。</p>
<p>(e)與(j)每次迭代執行兩個加載和一個儲存。內循環掃描B和C的行，每次迭代每個數組只有0.25次不命中，所以每次迭代有0.5次不命中。</p>
<p><img src="/pictures/CSAPP_U6/18.png" alt="18"></p>
<p>當<code>n</code>較大時，<code>kij</code>與<code>ikj</code>版本性能保持不變。這是因為<strong>預取(prefetching)</strong> 硬件識別出這是步長為1的訪問模式，事先在訪問之前將數據取到高速緩存中，使得就算數組大小大於SRAM可以存儲的大小也能保持良好性能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ilsao.github.io/">asciibase64</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ilsao.github.io/2025/07/18/CSAPP-U6-%E7%AD%86%E8%A8%98%E8%88%87-%E9%83%A8%E5%88%86-%E7%B7%B4%E7%BF%92%E9%A1%8C%E8%A7%A3%E7%AD%94/">https://ilsao.github.io/2025/07/18/CSAPP-U6-%E7%AD%86%E8%A8%98%E8%88%87-%E9%83%A8%E5%88%86-%E7%B7%B4%E7%BF%92%E9%A1%8C%E8%A7%A3%E7%AD%94/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ilsao.github.io" target="_blank">asciibase64</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%A8%88%E7%AE%97%E6%A9%9F%E5%BA%95%E5%B1%A4%E5%8E%9F%E7%90%86/">計算機底層原理</a></div><div class="post-share"><div class="social-share" data-image="/pictures/CSAPP_U6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/18/CSAPP-Cache-Lab-%E9%A1%8C%E8%A7%A3/" title="CSAPP Cache Lab 題解"><img class="cover" src="/pictures/CacheLab.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CSAPP Cache Lab 題解</div></div><div class="info-2"><div class="info-item-1">深入理解計算機系統Cache Lab題解</div></div></div></a><a class="pagination-related" href="/2025/07/08/CSAPP-U5-%E7%AD%86%E8%A8%98%E8%88%87-%E9%83%A8%E5%88%86-%E7%B7%B4%E7%BF%92%E9%A1%8C%E8%A7%A3%E7%AD%94/" title="CSAPP U5 筆記與(部分)練習題解答"><img class="cover" src="/pictures/CSAPP_U5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CSAPP U5 筆記與(部分)練習題解答</div></div><div class="info-2"><div class="info-item-1">深入理解計算機系統第五章筆記</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/04/CSAPP-Architecture-Lab-%E9%A1%8C%E8%A7%A3/" title="CSAPP Architecture Lab 題解"><img class="cover" src="/pictures/ArchLab.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-04</div><div class="info-item-2">CSAPP Architecture Lab 題解</div></div><div class="info-2"><div class="info-item-1">深入理解計算機系統官方Lab題解</div></div></div></a><a class="pagination-related" href="/2025/05/30/CSAPP-Attack-Lab-%E9%A1%8C%E8%A7%A3/" title="CSAPP Attack Lab 題解"><img class="cover" src="/pictures/AttackLab.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">CSAPP Attack Lab 題解</div></div><div class="info-2"><div class="info-item-1">深入理解計算機系統官方Lab題解</div></div></div></a><a class="pagination-related" href="/2025/07/18/CSAPP-Cache-Lab-%E9%A1%8C%E8%A7%A3/" title="CSAPP Cache Lab 題解"><img class="cover" src="/pictures/CacheLab.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">CSAPP Cache Lab 題解</div></div><div class="info-2"><div class="info-item-1">深入理解計算機系統Cache Lab題解</div></div></div></a><a class="pagination-related" href="/2025/08/10/CSAPP-U10-%E6%A5%B5%E7%B0%A1%E7%AD%86%E8%A8%98/" title="CSAPP U10 極簡筆記"><img class="cover" src="/pictures/CSAPP_U10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-10</div><div class="info-item-2">CSAPP U10 極簡筆記</div></div><div class="info-2"><div class="info-item-1">深入理解計算機系統第十章極簡筆記</div></div></div></a><a class="pagination-related" href="/2025/02/19/CSAPP-Data-Lab-%E9%A1%8C%E8%A7%A3/" title="CSAPP Data Lab 題解"><img class="cover" src="/pictures/DataLab.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-19</div><div class="info-item-2">CSAPP Data Lab 題解</div></div><div class="info-2"><div class="info-item-1">深入理解計算機系統官方Lab題解</div></div></div></a><a class="pagination-related" href="/2025/02/07/CSAPP-U2-%E7%AD%86%E8%A8%98%E8%88%87-%E9%83%A8%E5%88%86-%E7%B7%B4%E7%BF%92%E9%A1%8C%E8%A7%A3%E7%AD%94/" title="CSAPP U2 筆記與(部分)練習題解答"><img class="cover" src="/pictures/CSAPP_U2.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">CSAPP U2 筆記與(部分)練習題解答</div></div><div class="info-2"><div class="info-item-1">深入理解計算機系統第二章筆記</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/pictures/A4.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">asciibase64</div><div class="author-info-description">努力學習中的小菜鳥</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ilsao"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%84%B2%E6%8A%80%E8%A1%93"><span class="toc-number">1.</span> <span class="toc-text">存儲技術</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%A8%E6%A9%9F%E8%A8%AA%E5%95%8F%E5%AD%98%E5%84%B2%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">隨機訪問存儲器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9C%E6%85%8BRAM"><span class="toc-number">1.1.1.</span> <span class="toc-text">靜態RAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8B%95%E6%85%8BRAM"><span class="toc-number">1.1.2.</span> <span class="toc-text">動態RAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%82%B3%E7%B5%B1%E7%9A%84DRAM"><span class="toc-number">1.1.3.</span> <span class="toc-text">傳統的DRAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A7%E5%AD%98%E6%A8%A1%E5%A1%8A"><span class="toc-number">1.1.4.</span> <span class="toc-text">內存模塊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B7%B4%E7%BF%92%E9%A1%8C"><span class="toc-number">1.1.5.</span> <span class="toc-text">練習題</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%84%B2%E5%99%A8"><span class="toc-number">1.1.6.</span> <span class="toc-text">非易失性存儲器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A8%AA%E5%95%8F%E4%B8%BB%E5%AD%98"><span class="toc-number">1.1.7.</span> <span class="toc-text">訪問主存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%A4%E5%AD%98%E5%84%B2"><span class="toc-number">1.2.</span> <span class="toc-text">磁盤存儲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B7%B4%E7%BF%92%E9%A1%8C-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">練習題</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E6%85%8B%E7%A1%AC%E7%9B%A4"><span class="toc-number">1.3.</span> <span class="toc-text">固態硬盤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">局部性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B7%B4%E7%BF%92%E9%A1%8C-2"><span class="toc-number">1.5.</span> <span class="toc-text">練習題</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%84%B2%E5%99%A8%E5%B1%A4%E6%AC%A1%E7%B5%90%E6%A7%8B"><span class="toc-number">2.</span> <span class="toc-text">存儲器層次結構</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%84%B2%E5%99%A8%E5%B1%A4%E6%AC%A1%E7%B5%90%E6%A7%8B%E4%B8%AD%E7%9A%84%E7%B7%A9%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">存儲器層次結構中的緩存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%B7%A9%E5%AD%98%E5%AD%98%E5%84%B2%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">高速緩存存儲器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%9A%84%E9%AB%98%E9%80%9F%E7%B7%A9%E5%AD%98%E5%AD%98%E5%84%B2%E5%99%A8%E7%B5%84%E7%B9%94%E7%B5%90%E6%A7%8B"><span class="toc-number">3.1.</span> <span class="toc-text">通用的高速緩存存儲器組織結構</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B7%B4%E7%BF%92%E9%A1%8C-3"><span class="toc-number">3.1.1.</span> <span class="toc-text">練習題</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E9%AB%98%E9%80%9F%E7%B7%A9%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">直接映射高速緩存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B7%B4%E7%BF%92%E9%A1%8C-4"><span class="toc-number">3.2.1.</span> <span class="toc-text">練習題</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B5%84%E7%9B%B8%E8%81%AF%E9%AB%98%E9%80%9F%E7%B7%A9%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">組相聯高速緩存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E7%9B%B8%E8%81%AF%E9%AB%98%E9%80%9F%E7%B7%A9%E5%AD%98"><span class="toc-number">3.4.</span> <span class="toc-text">全相聯高速緩存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B7%B4%E7%BF%92%E9%A1%8C-5"><span class="toc-number">3.5.</span> <span class="toc-text">練習題</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E9%97%9C%E5%AF%AB%E7%9A%84%E5%95%8F%E9%A1%8C"><span class="toc-number">3.6.</span> <span class="toc-text">有關寫的問題</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B7%A8%E5%AF%AB%E9%AB%98%E9%80%9F%E7%B7%A9%E5%AD%98%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A2%BC"><span class="toc-number">4.</span> <span class="toc-text">編寫高速緩存友好的代碼</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B7%B4%E7%BF%92%E9%A1%8C-6"><span class="toc-number">4.1.</span> <span class="toc-text">練習題</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B6%9C%E5%90%88%EF%BC%9A%E9%AB%98%E9%80%9F%E7%B7%A9%E5%AD%98%E5%B0%8D%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E9%9F%BF"><span class="toc-number">5.</span> <span class="toc-text">綜合：高速緩存對程序性能的影響</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%BE%AA%E7%92%B0%E4%BB%A5%E6%8F%90%E9%AB%98%E7%A9%BA%E9%96%93%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">重新排列循環以提高空間局部性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/14/Introduction-to-Computer-Network/" title="Introduction to Computer Network"><img src="/pictures/computer_network_intro.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Introduction to Computer Network"/></a><div class="content"><a class="title" href="/2025/09/14/Introduction-to-Computer-Network/" title="Introduction to Computer Network">Introduction to Computer Network</a><time datetime="2025-09-13T17:23:04.837Z" title="更新于 2025-09-14 01:23:04">2025-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/xv6-%E9%99%B7%E5%85%A5%E6%A9%9F%E5%88%B6%E6%B7%BA%E6%9E%90/" title="xv6 陷入機制淺析"><img src="/pictures/xv6_syscall.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="xv6 陷入機制淺析"/></a><div class="content"><a class="title" href="/2025/08/30/xv6-%E9%99%B7%E5%85%A5%E6%A9%9F%E5%88%B6%E6%B7%BA%E6%9E%90/" title="xv6 陷入機制淺析">xv6 陷入機制淺析</a><time datetime="2025-08-30T13:36:27.182Z" title="更新于 2025-08-30 21:36:27">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/26/OSTEP-Virtualization/" title="OSTEP Virtualization"><img src="/pictures/OSTEP_Virtualization.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OSTEP Virtualization"/></a><div class="content"><a class="title" href="/2025/08/26/OSTEP-Virtualization/" title="OSTEP Virtualization">OSTEP Virtualization</a><time datetime="2025-08-26T09:04:03.629Z" title="更新于 2025-08-26 17:04:03">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/10/CSAPP-U10-%E6%A5%B5%E7%B0%A1%E7%AD%86%E8%A8%98/" title="CSAPP U10 極簡筆記"><img src="/pictures/CSAPP_U10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSAPP U10 極簡筆記"/></a><div class="content"><a class="title" href="/2025/08/10/CSAPP-U10-%E6%A5%B5%E7%B0%A1%E7%AD%86%E8%A8%98/" title="CSAPP U10 極簡筆記">CSAPP U10 極簡筆記</a><time datetime="2025-08-19T09:10:56.192Z" title="更新于 2025-08-19 17:10:56">2025-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/09/%E6%B7%BA%E8%AB%87%E5%85%A7%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E8%A8%AD%E8%A8%88/" title="淺談內存分配器設計"><img src="/pictures/MallocLab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="淺談內存分配器設計"/></a><div class="content"><a class="title" href="/2025/08/09/%E6%B7%BA%E8%AB%87%E5%85%A7%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E8%A8%AD%E8%A8%88/" title="淺談內存分配器設計">淺談內存分配器設計</a><time datetime="2025-08-09T09:01:42.725Z" title="更新于 2025-08-09 17:01:42">2025-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"><div id="footer-wrap"><div class="copyright">&copy;2025 By asciibase64</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Have a good day, mate!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'ilsao/ilsao.github.io',
      'data-repo-id': 'R_kgDONxqXQA',
      'data-category-id': 'DIC_kwDONxqXQM4CmeG9',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>